#!/usr/bin/env node

/**
 * ChromaDB Êï∞ÊçÆÁÆ°ÁêÜÂ∑•ÂÖ∑
 * ÊîØÊåÅÊï∞ÊçÆÊü•Áúã„ÄÅÂØºÂÖ•„ÄÅÂØºÂá∫„ÄÅÂ§á‰ªΩÁ≠âÂäüËÉΩ
 */

const chalk = require('chalk');
const fs = require('fs');
const path = require('path');

console.log(chalk.cyan(`
üóÑÔ∏è ChromaDB Êï∞ÊçÆÁÆ°ÁêÜÂ∑•ÂÖ∑
========================
`));

// ËæÖÂä©ÂáΩÊï∞ÔºöÊ®°ÊãüLangChainÁöÑChromaDBÂÆ¢Êà∑Á´Ø
async function createSampleData() {
  console.log(chalk.yellow('üìä Ê≠£Âú®ÂàõÂª∫Á§∫‰æãÊï∞ÊçÆ...'));
  
  try {
    // Ê£ÄÊü•ÊòØÂê¶ÊúâÁºñËØëÂ•ΩÁöÑÂ∫îÁî®
    if (!fs.existsSync('dist/index-langchain.js')) {
      console.log(chalk.red('‚ùå ËØ∑ÂÖàÁºñËØëÂ∫îÁî®: npm run build'));
      return;
    }
    
    // ËÆæÁΩÆÁéØÂ¢ÉÂèòÈáèÂπ∂ËøêË°åÂ∫îÁî®Êù•ÂàùÂßãÂåñÊï∞ÊçÆ
    console.log(chalk.blue('üöÄ ÂêØÂä® LangChain Â∫îÁî®Êù•ÂàùÂßãÂåñÊï∞ÊçÆ...'));
    
    const { spawn } = require('child_process');
    
    const env = {
      ...process.env,
      GEMINI_API_KEY: 'test_key_for_initialization',
      RAG_ENABLED: 'true',
      CHROMA_URL: 'localhost',
      CHROMA_PORT: '8000'
    };
    
    return new Promise((resolve, reject) => {
      const child = spawn('node', ['dist/index-langchain.js'], {
        env,
        stdio: 'pipe'
      });
      
      let output = '';
      child.stdout.on('data', (data) => {
        output += data.toString();
        console.log(chalk.gray(data.toString().trim()));
        
        // Ê£ÄÊü•ÊòØÂê¶ÂàùÂßãÂåñÂÆåÊàê
        if (output.includes('Á≥ªÁªüÂ∞±Áª™') || output.includes('LangChain AgentÂàùÂßãÂåñÂÆåÊàê')) {
          console.log(chalk.green('‚úÖ ÂàùÂßãÂåñÂÆåÊàêÔºåÊ≠£Âú®ÂÖ≥Èó≠Â∫îÁî®...'));
          setTimeout(() => {
            child.kill();
            resolve(true);
          }, 2000);
        }
      });
      
      child.stderr.on('data', (data) => {
        console.log(chalk.yellow('‚ö†Ô∏è', data.toString().trim()));
      });
      
      child.on('close', (code) => {
        resolve(code === 0);
      });
      
      // 10ÁßíË∂ÖÊó∂
      setTimeout(() => {
        child.kill();
        resolve(false);
      }, 10000);
    });
    
  } catch (error) {
    console.error(chalk.red('‚ùå ÂàõÂª∫Á§∫‰æãÊï∞ÊçÆÂ§±Ë¥•:'), error);
    return false;
  }
}

// ‰ΩøÁî®Áõ¥Êé•ÂëΩ‰ª§Êü•ÁúãDockerÂÆπÂô®ÂÜÖÁöÑÊï∞ÊçÆ
async function inspectContainerData() {
  console.log(chalk.yellow('üîç Ê£ÄÊü•ÂÆπÂô®ÂÜÖÁöÑÊï∞ÊçÆ...'));
  
  try {
    const { execSync } = require('child_process');
    
    // Ëé∑ÂèñChromaDBÂÆπÂô®ID
    const containers = execSync('docker ps --filter ancestor=chromadb/chroma --format "{{.ID}}"', { encoding: 'utf8' }).trim();
    
    if (!containers) {
      console.log(chalk.red('‚ùå Ê≤°ÊúâÊâæÂà∞ËøêË°å‰∏≠ÁöÑChromaDBÂÆπÂô®'));
      return;
    }
    
    const containerId = containers.split('\n')[0];
    console.log(chalk.blue(`üì¶ ÂÆπÂô®ID: ${containerId}`));
    
    // Êü•ÁúãÂÆπÂô®ÂÜÖÁöÑÊñá‰ª∂ÁªìÊûÑ
    console.log(chalk.yellow('üìÅ ÂÆπÂô®ÂÜÖÊñá‰ª∂ÁªìÊûÑ:'));
    try {
      const fileList = execSync(`docker exec ${containerId} find /chroma -type f 2>/dev/null || docker exec ${containerId} ls -la /`, { encoding: 'utf8' });
      console.log(chalk.gray(fileList));
    } catch (error) {
      console.log(chalk.gray('Êó†Ê≥ïËÆøÈóÆÂÆπÂô®Êñá‰ª∂Á≥ªÁªü'));
    }
    
    // Êü•ÁúãËøõÁ®ã
    console.log(chalk.yellow('üîÑ ÂÆπÂô®ÂÜÖËøõÁ®ã:'));
    try {
      const processes = execSync(`docker exec ${containerId} ps aux`, { encoding: 'utf8' });
      console.log(chalk.gray(processes));
    } catch (error) {
      console.log(chalk.gray('Êó†Ê≥ïÊü•ÁúãËøõÁ®ã‰ø°ÊÅØ'));
    }
    
  } catch (error) {
    console.error(chalk.red('‚ùå Ê£ÄÊü•ÂÆπÂô®Êï∞ÊçÆÂ§±Ë¥•:'), error.message);
  }
}

// ÂàõÂª∫ÊåÅ‰πÖÂåñÊï∞ÊçÆÂç∑ÁöÑChromaDB
async function createPersistentChromaDB() {
  console.log(chalk.yellow('üíæ ÂàõÂª∫ÊåÅ‰πÖÂåñÁöÑChromaDBÂÆû‰æã...'));
  
  try {
    const { execSync } = require('child_process');
    
    // ÂÅúÊ≠¢Áé∞ÊúâÂÆπÂô®
    try {
      execSync('docker stop $(docker ps -q --filter ancestor=chromadb/chroma)', { stdio: 'ignore' });
      console.log(chalk.blue('üõë Â∑≤ÂÅúÊ≠¢Áé∞ÊúâChromaDBÂÆπÂô®'));
    } catch (error) {
      // ÂøΩÁï•ÈîôËØØÔºåÂèØËÉΩÊ≤°ÊúâËøêË°åÁöÑÂÆπÂô®
    }
    
    // ÂàõÂª∫Êï∞ÊçÆÁõÆÂΩï
    const dataDir = path.join(process.cwd(), 'chromadb-data');
    if (!fs.existsSync(dataDir)) {
      fs.mkdirSync(dataDir, { recursive: true });
      console.log(chalk.green(`üìÅ ÂàõÂª∫Êï∞ÊçÆÁõÆÂΩï: ${dataDir}`));
    }
    
    // ÂêØÂä®Â∏¶ÊåÅ‰πÖÂåñÂ≠òÂÇ®ÁöÑChromaDB
    console.log(chalk.blue('üöÄ ÂêØÂä®ÊåÅ‰πÖÂåñChromaDB...'));
    const command = `docker run -d --name chromadb-persistent -p 8000:8000 -v "${dataDir}:/chroma/chroma" chromadb/chroma`;
    
    try {
      const result = execSync(command, { encoding: 'utf8' });
      console.log(chalk.green('‚úÖ ÊåÅ‰πÖÂåñChromaDBÂêØÂä®ÊàêÂäü'));
      console.log(chalk.blue(`üì¶ ÂÆπÂô®ID: ${result.trim()}`));
      console.log(chalk.cyan(`üíæ Êï∞ÊçÆÂ≠òÂÇ®Âú®: ${dataDir}`));
      
      // Á≠âÂæÖÊúçÂä°ÂêØÂä®
      await new Promise(resolve => setTimeout(resolve, 3000));
      
      return true;
    } catch (error) {
      console.error(chalk.red('‚ùå ÂêØÂä®Â§±Ë¥•:'), error.message);
      return false;
    }
    
  } catch (error) {
    console.error(chalk.red('‚ùå ÂàõÂª∫ÊåÅ‰πÖÂåñChromaDBÂ§±Ë¥•:'), error);
    return false;
  }
}

// Â§á‰ªΩChromaDBÊï∞ÊçÆ
async function backupData() {
  console.log(chalk.yellow('üíæ Â§á‰ªΩChromaDBÊï∞ÊçÆ...'));
  
  const dataDir = path.join(process.cwd(), 'chromadb-data');
  if (!fs.existsSync(dataDir)) {
    console.log(chalk.red('‚ùå Ê≤°ÊúâÊâæÂà∞Êï∞ÊçÆÁõÆÂΩïÔºåËØ∑ÂÖàÂàõÂª∫ÊåÅ‰πÖÂåñÂÆû‰æã'));
    return;
  }
  
  try {
    const { execSync } = require('child_process');
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const backupDir = path.join(process.cwd(), `chromadb-backup-${timestamp}`);
    
    // ÂàõÂª∫Â§á‰ªΩ
    execSync(`cp -r "${dataDir}" "${backupDir}"`, { encoding: 'utf8' });
    console.log(chalk.green(`‚úÖ Êï∞ÊçÆÂ∑≤Â§á‰ªΩÂà∞: ${backupDir}`));
    
    // ÂàõÂª∫Â§á‰ªΩ‰ø°ÊÅØÊñá‰ª∂
    const backupInfo = {
      timestamp: new Date().toISOString(),
      source: dataDir,
      backup: backupDir,
      files: fs.readdirSync(dataDir, { recursive: true })
    };
    
    fs.writeFileSync(path.join(backupDir, 'backup-info.json'), JSON.stringify(backupInfo, null, 2));
    console.log(chalk.blue('üìã Â§á‰ªΩ‰ø°ÊÅØÂ∑≤‰øùÂ≠ò'));
    
  } catch (error) {
    console.error(chalk.red('‚ùå Â§á‰ªΩÂ§±Ë¥•:'), error);
  }
}

// ‰∏ªËèúÂçï
function showMenu() {
  console.log(chalk.cyan(`
üìã ChromaDB Êï∞ÊçÆÁÆ°ÁêÜËèúÂçï:

1. üîç È¢ÑËßàÂΩìÂâçÊï∞ÊçÆÂ∫ìÁä∂ÊÄÅ
2. üìä ÂàõÂª∫Á§∫‰æãÊï∞ÊçÆ
3. üîç Ê£ÄÊü•ÂÆπÂô®ÂÜÖÊï∞ÊçÆ
4. üíæ ÂàõÂª∫ÊåÅ‰πÖÂåñChromaDBÂÆû‰æã
5. üíæ Â§á‰ªΩÊï∞ÊçÆ
6. üìÅ Êü•ÁúãÊï∞ÊçÆÁõÆÂΩï
7. üîÑ ÈáçÂêØChromaDBÊúçÂä°
8. ‚ùå ÈÄÄÂá∫

ÈÄâÊã©Êìç‰Ωú (1-8):`));
}

// Êü•ÁúãÊï∞ÊçÆÁõÆÂΩï
function viewDataDirectory() {
  const dataDir = path.join(process.cwd(), 'chromadb-data');
  
  if (fs.existsSync(dataDir)) {
    console.log(chalk.green(`üìÅ Êï∞ÊçÆÁõÆÂΩï: ${dataDir}`));
    console.log(chalk.blue('üìÇ ÁõÆÂΩïÂÜÖÂÆπ:'));
    
    function listFiles(dir, indent = '') {
      const items = fs.readdirSync(dir);
      items.forEach(item => {
        const itemPath = path.join(dir, item);
        const stats = fs.statSync(itemPath);
        
        if (stats.isDirectory()) {
          console.log(chalk.blue(`${indent}üìÅ ${item}/`));
          if (indent.length < 6) { // ÈôêÂà∂ÈÄíÂΩíÊ∑±Â∫¶
            listFiles(itemPath, indent + '  ');
          }
        } else {
          console.log(chalk.gray(`${indent}üìÑ ${item} (${stats.size} bytes)`));
        }
      });
    }
    
    listFiles(dataDir);
  } else {
    console.log(chalk.yellow('‚ö†Ô∏è Êï∞ÊçÆÁõÆÂΩï‰∏çÂ≠òÂú®Ôºå‰ΩøÁî®‰∏¥Êó∂Â≠òÂÇ®'));
    console.log(chalk.blue('üí° ËøêË°åÈÄâÈ°π4ÂàõÂª∫ÊåÅ‰πÖÂåñÂÆû‰æã'));
  }
}

// ÈáçÂêØÊúçÂä°
async function restartService() {
  console.log(chalk.yellow('üîÑ ÈáçÂêØChromaDBÊúçÂä°...'));
  
  try {
    const { execSync } = require('child_process');
    
    // ÂÅúÊ≠¢ÊâÄÊúâChromaDBÂÆπÂô®
    try {
      execSync('docker stop $(docker ps -q --filter ancestor=chromadb/chroma)', { stdio: 'ignore' });
      execSync('docker rm $(docker ps -aq --filter ancestor=chromadb/chroma)', { stdio: 'ignore' });
    } catch (error) {
      // ÂøΩÁï•ÈîôËØØ
    }
    
    // ÈáçÊñ∞ÂêØÂä®
    const dataDir = path.join(process.cwd(), 'chromadb-data');
    if (fs.existsSync(dataDir)) {
      console.log(chalk.blue('üöÄ ÂêØÂä®ÊåÅ‰πÖÂåñChromaDB...'));
      execSync(`docker run -d --name chromadb-persistent -p 8000:8000 -v "${dataDir}:/chroma/chroma" chromadb/chroma`);
    } else {
      console.log(chalk.blue('üöÄ ÂêØÂä®‰∏¥Êó∂ChromaDB...'));
      execSync('docker run -d -p 8000:8000 chromadb/chroma');
    }
    
    console.log(chalk.green('‚úÖ ÊúçÂä°ÈáçÂêØÂÆåÊàê'));
    
  } catch (error) {
    console.error(chalk.red('‚ùå ÈáçÂêØÂ§±Ë¥•:'), error.message);
  }
}

// ‰∫§‰∫íÂºè‰∏ªÁ®ãÂ∫è
async function main() {
  const readline = require('readline');
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
  });

  function askQuestion(question) {
    return new Promise((resolve) => {
      rl.question(question, (answer) => {
        resolve(answer.trim());
      });
    });
  }

  try {
    while (true) {
      showMenu();
      const choice = await askQuestion('');

      switch (choice) {
        case '1':
          const { execSync } = require('child_process');
          execSync('node scripts/preview-chromadb.js', { stdio: 'inherit' });
          break;
        case '2':
          await createSampleData();
          break;
        case '3':
          await inspectContainerData();
          break;
        case '4':
          await createPersistentChromaDB();
          break;
        case '5':
          await backupData();
          break;
        case '6':
          viewDataDirectory();
          break;
        case '7':
          await restartService();
          break;
        case '8':
          console.log(chalk.cyan('üëã ÂÜçËßÅÔºÅ'));
          rl.close();
          process.exit(0);
        default:
          console.log(chalk.red('‚ùå Êó†ÊïàÈÄâÊã©ÔºåËØ∑ËæìÂÖ•1-8'));
      }

      console.log(chalk.gray('\nÊåâ‰ªªÊÑèÈîÆÁªßÁª≠...'));
      await askQuestion('');
    }
  } catch (error) {
    console.error(chalk.red('‚ùå Á®ãÂ∫èÈîôËØØ:'), error);
  } finally {
    rl.close();
  }
}

// Â¶ÇÊûúÁõ¥Êé•ËøêË°åËÑöÊú¨ÔºåÂêØÂä®‰∫§‰∫íÂºèËèúÂçï
if (require.main === module) {
  main().catch(console.error);
}

module.exports = {
  createSampleData,
  inspectContainerData,
  createPersistentChromaDB,
  backupData
}; 